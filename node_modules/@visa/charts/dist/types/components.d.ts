/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "./stencil-public-runtime";
import { IAccessibilityType, IAnimationConfig, IAxisType, IBarStyleType, IBoxModelType, IClickStyleType, ICountryStyleType, IDataLabelType, IDifferenceLabelType, IFocusStyleType, IHoverStyleType, ILegendType, ILinkConfigType, ILocalizationType, IMapMarkerStyleType, IMarkerStyleType, INodeConfigType, IReferenceStyleType, ISecondaryLinesType, ISeriesLabelType, ISubTitleType, ITooltipLabelType } from "@visa/charts-types";
export { IAccessibilityType, IAnimationConfig, IAxisType, IBarStyleType, IBoxModelType, IClickStyleType, ICountryStyleType, IDataLabelType, IDifferenceLabelType, IFocusStyleType, IHoverStyleType, ILegendType, ILinkConfigType, ILocalizationType, IMapMarkerStyleType, IMarkerStyleType, INodeConfigType, IReferenceStyleType, ISecondaryLinesType, ISeriesLabelType, ISubTitleType, ITooltipLabelType } from "@visa/charts-types";
export namespace Components {
    interface AlluvialDiagram {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colors": string[];
        "cursor": string;
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "groupAccessor": string;
        "height": number;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "interactionKeys": string[];
        "layout": string;
        "linkConfig": ILinkConfigType;
        "linkData": object[];
        "localization": ILocalizationType;
        "mainTitle": string;
        "margin": IBoxModelType;
        "nodeConfig": INodeConfigType;
        "nodeData": object[];
        "nodeIDAccessor": string;
        "padding": IBoxModelType;
        "showTooltip": boolean;
        "sourceAccessor": string;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "targetAccessor": string;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": string;
        "unitTest": boolean;
        "valueAccessor": string;
        "width": number;
    }
    interface BarChart {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "barIntervalRatio": number;
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colors": string[];
        "cursor": string;
        "data": object[];
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "groupAccessor": string;
        "height": number;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "interactionKeys": string[];
        "layout": string;
        "legend": ILegendType;
        "localization": ILocalizationType;
        "mainTitle": string;
        "margin": IBoxModelType;
        "maxValueOverride": number;
        "minValueOverride": number;
        "ordinalAccessor": string;
        "padding": IBoxModelType;
        "referenceLines": object[];
        "referenceStyle": IReferenceStyleType;
        "roundedCorner": number;
        "showTooltip": boolean;
        "sortOrder": string;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": string;
        "unitTest": boolean;
        "valueAccessor": string;
        "width": number;
        "wrapLabel": boolean;
        "xAxis": IAxisType;
        "yAxis": IAxisType;
    }
    interface CirclePacking {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "circlePadding": number;
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colors": string[];
        "cursor": string;
        "data": any;
        "dataDepth": number;
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "displayDepth": number;
        "height": number;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "interactionKeys": string[];
        "localization": ILocalizationType;
        "mainTitle": string;
        "margin": IBoxModelType;
        "nodeAccessor": string;
        "padding": IBoxModelType;
        "parentAccessor": string;
        "showTooltip": boolean;
        "sizeAccessor": string;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": any;
        "width": number;
        "zoomToNode": object;
    }
    interface ClusteredBarChart {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "barIntervalRatio": number;
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colors": string[];
        "cursor": string;
        "data": any;
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "groupAccessor": string;
        "groupIntervalRatio": number;
        "height": number;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "interactionKeys": string[];
        "layout": string;
        "legend": ILegendType;
        "localization": ILocalizationType;
        "mainTitle": string;
        "margin": IBoxModelType;
        "maxValueOverride": number;
        "minValueOverride": number;
        "ordinalAccessor": string;
        "padding": IBoxModelType;
        "referenceLines": object[];
        "referenceStyle": IReferenceStyleType;
        "reverseOrder": boolean;
        "roundedCorner": number;
        "showTooltip": boolean;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": any;
        "unitTest": boolean;
        "valueAccessor": string;
        "width": number;
        "wrapLabel": boolean;
        "xAxis": IAxisType;
        "yAxis": IAxisType;
    }
    interface DataTable {
        "data": object[];
        "dataKeyNames": object;
        "hideDataTable": boolean;
        "isCompact": boolean;
        "language": string;
        "margin": IBoxModelType;
        "padding": IBoxModelType;
        "secondaryData": object[];
        "secondaryTableColumns": string[];
        "tableColumns": string[];
        "uniqueID": string;
        "unitTest": boolean;
    }
    interface DumbbellPlot {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "barStyle": IBarStyleType;
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colors": string[];
        "cursor": string;
        "data": object[];
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "differenceLabel": IDifferenceLabelType;
        "focusMarker": IFocusStyleType;
        "height": number;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "interactionKeys": string[];
        "layout": string;
        "legend": ILegendType;
        "localization": ILocalizationType;
        "mainTitle": string;
        "margin": IBoxModelType;
        "marker": IMarkerStyleType;
        "maxValueOverride": number;
        "minValueOverride": number;
        "ordinalAccessor": string;
        "padding": IBoxModelType;
        "referenceLines": object[];
        "referenceStyle": IReferenceStyleType;
        "seriesAccessor": string;
        "seriesLabel": ISeriesLabelType;
        "showBaselineX": boolean;
        "showBaselineY": boolean;
        "showTooltip": boolean;
        "sortOrder": string;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": string;
        "unitTest": boolean;
        "valueAccessor": string;
        "width": number;
        "wrapLabel": boolean;
        "xAxis": IAxisType;
        "yAxis": IAxisType;
    }
    interface HeatMap {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colorSteps": number;
        "colors": string[];
        "cursor": string;
        "data": object[];
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "height": number;
        "hideAxisPath": boolean;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "interactionKeys": string[];
        "legend": ILegendType;
        "localization": ILocalizationType;
        "mainTitle": string;
        "margin": IBoxModelType;
        "maxValueOverride": number;
        "minValueOverride": number;
        "padding": IBoxModelType;
        "shape": string;
        "showTooltip": boolean;
        "strokeWidth": number;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": string;
        "unitTest": boolean;
        "valueAccessor": string;
        "width": number;
        "wrapLabel": boolean;
        "xAccessor": string;
        "xAxis": IAxisType;
        "xKeyOrder": string[];
        "yAccessor": string;
        "yAxis": IAxisType;
        "yKeyOrder": string[];
    }
    interface KeyboardInstructions {
        "chartTag": string;
        "disabled": boolean;
        "geomType": string;
        "groupName": string;
        "hasCousinNavigation": boolean;
        "isInteractive": boolean;
        "language": string;
        "uniqueID": string;
        "unitTest": boolean;
        "width": number | string;
    }
    interface LineChart {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colors": string[];
        "cursor": string;
        "data": object[];
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "dotRadius": number;
        "height": number;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "interactionKeys": string[];
        "legend": ILegendType;
        "lineCurve": string;
        "localization": ILocalizationType;
        "mainTitle": string;
        "margin": IBoxModelType;
        "maxValueOverride": number;
        "minValueOverride": number;
        "ordinalAccessor": string;
        "padding": IBoxModelType;
        "referenceLines": object[];
        "referenceStyle": IReferenceStyleType;
        "secondaryLines": ISecondaryLinesType;
        "seriesAccessor": string;
        "seriesLabel": ISeriesLabelType;
        "showBaselineX": boolean;
        "showDots": boolean;
        "showTooltip": boolean;
        "strokeWidth": number;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": string;
        "unitTest": boolean;
        "valueAccessor": string;
        "width": number;
        "wrapLabel": boolean;
        "xAxis": IAxisType;
        "yAxis": IAxisType;
    }
    interface ParallelPlot {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colors": string[];
        "cursor": string;
        "data": object[];
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "dotRadius": number;
        "height": number;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "interactionKeys": string[];
        "legend": ILegendType;
        "lineCurve": string;
        "localization": ILocalizationType;
        "mainTitle": string;
        "margin": IBoxModelType;
        "maxValueOverride": number;
        "minValueOverride": number;
        "ordinalAccessor": string;
        "padding": IBoxModelType;
        "secondaryLines": ISecondaryLinesType;
        "seriesAccessor": string;
        "seriesLabel": ISeriesLabelType;
        "showBaselineX": boolean;
        "showDots": boolean;
        "showTooltip": boolean;
        "strokeWidth": number;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": string;
        "unitTest": boolean;
        "valueAccessor": string;
        "width": number;
        "wrapLabel": boolean;
        "xAxis": IAxisType;
        "yAxis": IAxisType;
    }
    interface PieChart {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "centerSubTitle": string;
        "centerTitle": string;
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colors": string[];
        "cursor": string;
        "data": object[];
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "height": number;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "innerRatio": number;
        "interactionKeys": string[];
        "labelOffset": number;
        "localization": ILocalizationType;
        "mainTitle": string;
        "margin": IBoxModelType;
        "ordinalAccessor": string;
        "padding": IBoxModelType;
        "referenceData": object[];
        "referenceStyle": IReferenceStyleType;
        "showEdgeLine": boolean;
        "showLabelNote": boolean;
        "showPercentage": boolean;
        "showTooltip": boolean;
        "sortOrder": string;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": string;
        "unitTest": boolean;
        "valueAccessor": string;
        "width": number;
    }
    interface ScatterPlot {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colors": string[];
        "cursor": string;
        "data": object[];
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "dotOpacity": number;
        "dotRadius": number;
        "dotSymbols": string[];
        "fitLineStyle": IReferenceStyleType;
        "groupAccessor": string;
        "height": number;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "interactionKeys": string[];
        "legend": ILegendType;
        "localization": ILocalizationType;
        "mainTitle": string;
        "margin": IBoxModelType;
        "padding": IBoxModelType;
        "referenceLines": object[];
        "referenceStyle": IReferenceStyleType;
        "showBaselineX": boolean;
        "showBaselineY": boolean;
        "showFitLine": boolean;
        "showTooltip": boolean;
        "sizeConfig": any;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": string;
        "unitTest": boolean;
        "width": number;
        "xAccessor": string;
        "xAxis": IAxisType;
        "xMaxValueOverride": number;
        "xMinValueOverride": number;
        "yAccessor": string;
        "yAxis": IAxisType;
        "yMaxValueOverride": number;
        "yMinValueOverride": number;
    }
    interface StackedBarChart {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "barIntervalRatio": number;
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colors": string[];
        "cursor": string;
        "data": object[];
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "groupAccessor": string;
        "height": number;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "interactionKeys": string[];
        "layout": string;
        "legend": ILegendType;
        "localization": ILocalizationType;
        "mainTitle": string;
        "margin": IBoxModelType;
        "maxValueOverride": number;
        "minValueOverride": number;
        "normalized": boolean;
        "ordinalAccessor": string;
        "padding": IBoxModelType;
        "referenceLines": object[];
        "referenceStyle": IReferenceStyleType;
        "roundedCorner": number;
        "showTooltip": boolean;
        "showTotalValue": boolean;
        "showZeroLabels": boolean;
        "sortOrder": string;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": string;
        "unitTest": boolean;
        "valueAccessor": string;
        "width": number;
        "wrapLabel": boolean;
        "xAxis": IAxisType;
        "yAxis": IAxisType;
    }
    interface WorldMap {
        "accessibility": IAccessibilityType;
        "animationConfig": IAnimationConfig;
        "annotations": object[];
        "clickHighlight": object[];
        "clickStyle": IClickStyleType;
        "colorPalette": string;
        "colorSteps": number;
        "colors": string[];
        "countryStyle": ICountryStyleType;
        "cursor": string;
        "data": object[];
        "dataKeyNames": object;
        "dataLabel": IDataLabelType;
        "groupAccessor": string;
        "height": number;
        "highestHeadingLevel": string | number;
        "hoverHighlight": object;
        "hoverOpacity": number;
        "hoverStyle": IHoverStyleType;
        "interactionKeys": string[];
        "joinAccessor": string;
        "joinNameAccessor": string;
        "latitudeAccessor": string;
        "legend": ILegendType;
        "localization": ILocalizationType;
        "longitudeAccessor": string;
        "mainTitle": string;
        "mapProjection": string;
        "mapScaleZoom": number;
        "margin": IBoxModelType;
        "markerAccessor": string;
        "markerNameAccessor": string;
        "markerStyle": IMapMarkerStyleType;
        "maxValueOverride": number;
        "minValueOverride": number;
        "padding": IBoxModelType;
        "quality": string;
        "showGridlines": boolean;
        "showTooltip": boolean;
        "sortOrder": string;
        "subTitle": string | ISubTitleType;
        "suppressEvents": boolean;
        "tooltipLabel": ITooltipLabelType;
        "uniqueID": string;
        "unitTest": boolean;
        "valueAccessor": string;
        "width": number;
    }
}
export interface AlluvialDiagramCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLAlluvialDiagramElement;
}
export interface BarChartCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLBarChartElement;
}
export interface CirclePackingCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCirclePackingElement;
}
export interface ClusteredBarChartCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLClusteredBarChartElement;
}
export interface DumbbellPlotCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLDumbbellPlotElement;
}
export interface HeatMapCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLHeatMapElement;
}
export interface LineChartCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLLineChartElement;
}
export interface ParallelPlotCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLParallelPlotElement;
}
export interface PieChartCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPieChartElement;
}
export interface ScatterPlotCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLScatterPlotElement;
}
export interface StackedBarChartCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLStackedBarChartElement;
}
export interface WorldMapCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWorldMapElement;
}
declare global {
    interface HTMLAlluvialDiagramElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLAlluvialDiagramElement extends Components.AlluvialDiagram, HTMLStencilElement {
        addEventListener<K extends keyof HTMLAlluvialDiagramElementEventMap>(type: K, listener: (this: HTMLAlluvialDiagramElement, ev: AlluvialDiagramCustomEvent<HTMLAlluvialDiagramElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLAlluvialDiagramElementEventMap>(type: K, listener: (this: HTMLAlluvialDiagramElement, ev: AlluvialDiagramCustomEvent<HTMLAlluvialDiagramElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLAlluvialDiagramElement: {
        prototype: HTMLAlluvialDiagramElement;
        new (): HTMLAlluvialDiagramElement;
    };
    interface HTMLBarChartElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLBarChartElement extends Components.BarChart, HTMLStencilElement {
        addEventListener<K extends keyof HTMLBarChartElementEventMap>(type: K, listener: (this: HTMLBarChartElement, ev: BarChartCustomEvent<HTMLBarChartElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLBarChartElementEventMap>(type: K, listener: (this: HTMLBarChartElement, ev: BarChartCustomEvent<HTMLBarChartElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLBarChartElement: {
        prototype: HTMLBarChartElement;
        new (): HTMLBarChartElement;
    };
    interface HTMLCirclePackingElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLCirclePackingElement extends Components.CirclePacking, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCirclePackingElementEventMap>(type: K, listener: (this: HTMLCirclePackingElement, ev: CirclePackingCustomEvent<HTMLCirclePackingElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCirclePackingElementEventMap>(type: K, listener: (this: HTMLCirclePackingElement, ev: CirclePackingCustomEvent<HTMLCirclePackingElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCirclePackingElement: {
        prototype: HTMLCirclePackingElement;
        new (): HTMLCirclePackingElement;
    };
    interface HTMLClusteredBarChartElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLClusteredBarChartElement extends Components.ClusteredBarChart, HTMLStencilElement {
        addEventListener<K extends keyof HTMLClusteredBarChartElementEventMap>(type: K, listener: (this: HTMLClusteredBarChartElement, ev: ClusteredBarChartCustomEvent<HTMLClusteredBarChartElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLClusteredBarChartElementEventMap>(type: K, listener: (this: HTMLClusteredBarChartElement, ev: ClusteredBarChartCustomEvent<HTMLClusteredBarChartElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLClusteredBarChartElement: {
        prototype: HTMLClusteredBarChartElement;
        new (): HTMLClusteredBarChartElement;
    };
    interface HTMLDataTableElement extends Components.DataTable, HTMLStencilElement {
    }
    var HTMLDataTableElement: {
        prototype: HTMLDataTableElement;
        new (): HTMLDataTableElement;
    };
    interface HTMLDumbbellPlotElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLDumbbellPlotElement extends Components.DumbbellPlot, HTMLStencilElement {
        addEventListener<K extends keyof HTMLDumbbellPlotElementEventMap>(type: K, listener: (this: HTMLDumbbellPlotElement, ev: DumbbellPlotCustomEvent<HTMLDumbbellPlotElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLDumbbellPlotElementEventMap>(type: K, listener: (this: HTMLDumbbellPlotElement, ev: DumbbellPlotCustomEvent<HTMLDumbbellPlotElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLDumbbellPlotElement: {
        prototype: HTMLDumbbellPlotElement;
        new (): HTMLDumbbellPlotElement;
    };
    interface HTMLHeatMapElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLHeatMapElement extends Components.HeatMap, HTMLStencilElement {
        addEventListener<K extends keyof HTMLHeatMapElementEventMap>(type: K, listener: (this: HTMLHeatMapElement, ev: HeatMapCustomEvent<HTMLHeatMapElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLHeatMapElementEventMap>(type: K, listener: (this: HTMLHeatMapElement, ev: HeatMapCustomEvent<HTMLHeatMapElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLHeatMapElement: {
        prototype: HTMLHeatMapElement;
        new (): HTMLHeatMapElement;
    };
    interface HTMLKeyboardInstructionsElement extends Components.KeyboardInstructions, HTMLStencilElement {
    }
    var HTMLKeyboardInstructionsElement: {
        prototype: HTMLKeyboardInstructionsElement;
        new (): HTMLKeyboardInstructionsElement;
    };
    interface HTMLLineChartElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLLineChartElement extends Components.LineChart, HTMLStencilElement {
        addEventListener<K extends keyof HTMLLineChartElementEventMap>(type: K, listener: (this: HTMLLineChartElement, ev: LineChartCustomEvent<HTMLLineChartElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLLineChartElementEventMap>(type: K, listener: (this: HTMLLineChartElement, ev: LineChartCustomEvent<HTMLLineChartElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLLineChartElement: {
        prototype: HTMLLineChartElement;
        new (): HTMLLineChartElement;
    };
    interface HTMLParallelPlotElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLParallelPlotElement extends Components.ParallelPlot, HTMLStencilElement {
        addEventListener<K extends keyof HTMLParallelPlotElementEventMap>(type: K, listener: (this: HTMLParallelPlotElement, ev: ParallelPlotCustomEvent<HTMLParallelPlotElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLParallelPlotElementEventMap>(type: K, listener: (this: HTMLParallelPlotElement, ev: ParallelPlotCustomEvent<HTMLParallelPlotElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLParallelPlotElement: {
        prototype: HTMLParallelPlotElement;
        new (): HTMLParallelPlotElement;
    };
    interface HTMLPieChartElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLPieChartElement extends Components.PieChart, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPieChartElementEventMap>(type: K, listener: (this: HTMLPieChartElement, ev: PieChartCustomEvent<HTMLPieChartElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPieChartElementEventMap>(type: K, listener: (this: HTMLPieChartElement, ev: PieChartCustomEvent<HTMLPieChartElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPieChartElement: {
        prototype: HTMLPieChartElement;
        new (): HTMLPieChartElement;
    };
    interface HTMLScatterPlotElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLScatterPlotElement extends Components.ScatterPlot, HTMLStencilElement {
        addEventListener<K extends keyof HTMLScatterPlotElementEventMap>(type: K, listener: (this: HTMLScatterPlotElement, ev: ScatterPlotCustomEvent<HTMLScatterPlotElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLScatterPlotElementEventMap>(type: K, listener: (this: HTMLScatterPlotElement, ev: ScatterPlotCustomEvent<HTMLScatterPlotElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLScatterPlotElement: {
        prototype: HTMLScatterPlotElement;
        new (): HTMLScatterPlotElement;
    };
    interface HTMLStackedBarChartElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLStackedBarChartElement extends Components.StackedBarChart, HTMLStencilElement {
        addEventListener<K extends keyof HTMLStackedBarChartElementEventMap>(type: K, listener: (this: HTMLStackedBarChartElement, ev: StackedBarChartCustomEvent<HTMLStackedBarChartElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLStackedBarChartElementEventMap>(type: K, listener: (this: HTMLStackedBarChartElement, ev: StackedBarChartCustomEvent<HTMLStackedBarChartElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLStackedBarChartElement: {
        prototype: HTMLStackedBarChartElement;
        new (): HTMLStackedBarChartElement;
    };
    interface HTMLWorldMapElementEventMap {
        "clickEvent": any;
        "hoverEvent": any;
        "mouseOutEvent": any;
        "initialLoadEvent": any;
        "initialLoadEndEvent": any;
        "drawStartEvent": any;
        "drawEndEvent": any;
        "transitionEndEvent": any;
    }
    interface HTMLWorldMapElement extends Components.WorldMap, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWorldMapElementEventMap>(type: K, listener: (this: HTMLWorldMapElement, ev: WorldMapCustomEvent<HTMLWorldMapElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWorldMapElementEventMap>(type: K, listener: (this: HTMLWorldMapElement, ev: WorldMapCustomEvent<HTMLWorldMapElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWorldMapElement: {
        prototype: HTMLWorldMapElement;
        new (): HTMLWorldMapElement;
    };
    interface HTMLElementTagNameMap {
        "alluvial-diagram": HTMLAlluvialDiagramElement;
        "bar-chart": HTMLBarChartElement;
        "circle-packing": HTMLCirclePackingElement;
        "clustered-bar-chart": HTMLClusteredBarChartElement;
        "data-table": HTMLDataTableElement;
        "dumbbell-plot": HTMLDumbbellPlotElement;
        "heat-map": HTMLHeatMapElement;
        "keyboard-instructions": HTMLKeyboardInstructionsElement;
        "line-chart": HTMLLineChartElement;
        "parallel-plot": HTMLParallelPlotElement;
        "pie-chart": HTMLPieChartElement;
        "scatter-plot": HTMLScatterPlotElement;
        "stacked-bar-chart": HTMLStackedBarChartElement;
        "world-map": HTMLWorldMapElement;
    }
}
declare namespace LocalJSX {
    interface AlluvialDiagram {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colors"?: string[];
        "cursor"?: string;
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "groupAccessor"?: string;
        "height"?: number;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "interactionKeys"?: string[];
        "layout"?: string;
        "linkConfig"?: ILinkConfigType;
        "linkData"?: object[];
        "localization"?: ILocalizationType;
        "mainTitle"?: string;
        "margin"?: IBoxModelType;
        "nodeConfig"?: INodeConfigType;
        "nodeData"?: object[];
        "nodeIDAccessor"?: string;
        "onClickEvent"?: (event: AlluvialDiagramCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: AlluvialDiagramCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: AlluvialDiagramCustomEvent<any>) => void;
        "onHoverEvent"?: (event: AlluvialDiagramCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: AlluvialDiagramCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: AlluvialDiagramCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: AlluvialDiagramCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: AlluvialDiagramCustomEvent<any>) => void;
        "padding"?: IBoxModelType;
        "showTooltip"?: boolean;
        "sourceAccessor"?: string;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "targetAccessor"?: string;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: string;
        "unitTest"?: boolean;
        "valueAccessor"?: string;
        "width"?: number;
    }
    interface BarChart {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "barIntervalRatio"?: number;
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colors"?: string[];
        "cursor"?: string;
        "data"?: object[];
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "groupAccessor"?: string;
        "height"?: number;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "interactionKeys"?: string[];
        "layout"?: string;
        "legend"?: ILegendType;
        "localization"?: ILocalizationType;
        "mainTitle"?: string;
        "margin"?: IBoxModelType;
        "maxValueOverride"?: number;
        "minValueOverride"?: number;
        "onClickEvent"?: (event: BarChartCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: BarChartCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: BarChartCustomEvent<any>) => void;
        "onHoverEvent"?: (event: BarChartCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: BarChartCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: BarChartCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: BarChartCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: BarChartCustomEvent<any>) => void;
        "ordinalAccessor"?: string;
        "padding"?: IBoxModelType;
        "referenceLines"?: object[];
        "referenceStyle"?: IReferenceStyleType;
        "roundedCorner"?: number;
        "showTooltip"?: boolean;
        "sortOrder"?: string;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: string;
        "unitTest"?: boolean;
        "valueAccessor"?: string;
        "width"?: number;
        "wrapLabel"?: boolean;
        "xAxis"?: IAxisType;
        "yAxis"?: IAxisType;
    }
    interface CirclePacking {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "circlePadding"?: number;
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colors"?: string[];
        "cursor"?: string;
        "data"?: any;
        "dataDepth"?: number;
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "displayDepth"?: number;
        "height"?: number;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "interactionKeys"?: string[];
        "localization"?: ILocalizationType;
        "mainTitle"?: string;
        "margin"?: IBoxModelType;
        "nodeAccessor"?: string;
        "onClickEvent"?: (event: CirclePackingCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: CirclePackingCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: CirclePackingCustomEvent<any>) => void;
        "onHoverEvent"?: (event: CirclePackingCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: CirclePackingCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: CirclePackingCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: CirclePackingCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: CirclePackingCustomEvent<any>) => void;
        "padding"?: IBoxModelType;
        "parentAccessor"?: string;
        "showTooltip"?: boolean;
        "sizeAccessor"?: string;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: any;
        "width"?: number;
        "zoomToNode"?: object;
    }
    interface ClusteredBarChart {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "barIntervalRatio"?: number;
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colors"?: string[];
        "cursor"?: string;
        "data"?: any;
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "groupAccessor"?: string;
        "groupIntervalRatio"?: number;
        "height"?: number;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "interactionKeys"?: string[];
        "layout"?: string;
        "legend"?: ILegendType;
        "localization"?: ILocalizationType;
        "mainTitle"?: string;
        "margin"?: IBoxModelType;
        "maxValueOverride"?: number;
        "minValueOverride"?: number;
        "onClickEvent"?: (event: ClusteredBarChartCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: ClusteredBarChartCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: ClusteredBarChartCustomEvent<any>) => void;
        "onHoverEvent"?: (event: ClusteredBarChartCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: ClusteredBarChartCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: ClusteredBarChartCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: ClusteredBarChartCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: ClusteredBarChartCustomEvent<any>) => void;
        "ordinalAccessor"?: string;
        "padding"?: IBoxModelType;
        "referenceLines"?: object[];
        "referenceStyle"?: IReferenceStyleType;
        "reverseOrder"?: boolean;
        "roundedCorner"?: number;
        "showTooltip"?: boolean;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: any;
        "unitTest"?: boolean;
        "valueAccessor"?: string;
        "width"?: number;
        "wrapLabel"?: boolean;
        "xAxis"?: IAxisType;
        "yAxis"?: IAxisType;
    }
    interface DataTable {
        "data"?: object[];
        "dataKeyNames"?: object;
        "hideDataTable"?: boolean;
        "isCompact"?: boolean;
        "language"?: string;
        "margin"?: IBoxModelType;
        "padding"?: IBoxModelType;
        "secondaryData"?: object[];
        "secondaryTableColumns"?: string[];
        "tableColumns"?: string[];
        "uniqueID"?: string;
        "unitTest"?: boolean;
    }
    interface DumbbellPlot {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "barStyle"?: IBarStyleType;
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colors"?: string[];
        "cursor"?: string;
        "data"?: object[];
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "differenceLabel"?: IDifferenceLabelType;
        "focusMarker"?: IFocusStyleType;
        "height"?: number;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "interactionKeys"?: string[];
        "layout"?: string;
        "legend"?: ILegendType;
        "localization"?: ILocalizationType;
        "mainTitle"?: string;
        "margin"?: IBoxModelType;
        "marker"?: IMarkerStyleType;
        "maxValueOverride"?: number;
        "minValueOverride"?: number;
        "onClickEvent"?: (event: DumbbellPlotCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: DumbbellPlotCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: DumbbellPlotCustomEvent<any>) => void;
        "onHoverEvent"?: (event: DumbbellPlotCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: DumbbellPlotCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: DumbbellPlotCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: DumbbellPlotCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: DumbbellPlotCustomEvent<any>) => void;
        "ordinalAccessor"?: string;
        "padding"?: IBoxModelType;
        "referenceLines"?: object[];
        "referenceStyle"?: IReferenceStyleType;
        "seriesAccessor"?: string;
        "seriesLabel"?: ISeriesLabelType;
        "showBaselineX"?: boolean;
        "showBaselineY"?: boolean;
        "showTooltip"?: boolean;
        "sortOrder"?: string;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: string;
        "unitTest"?: boolean;
        "valueAccessor"?: string;
        "width"?: number;
        "wrapLabel"?: boolean;
        "xAxis"?: IAxisType;
        "yAxis"?: IAxisType;
    }
    interface HeatMap {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colorSteps"?: number;
        "colors"?: string[];
        "cursor"?: string;
        "data"?: object[];
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "height"?: number;
        "hideAxisPath"?: boolean;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "interactionKeys"?: string[];
        "legend"?: ILegendType;
        "localization"?: ILocalizationType;
        "mainTitle"?: string;
        "margin"?: IBoxModelType;
        "maxValueOverride"?: number;
        "minValueOverride"?: number;
        "onClickEvent"?: (event: HeatMapCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: HeatMapCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: HeatMapCustomEvent<any>) => void;
        "onHoverEvent"?: (event: HeatMapCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: HeatMapCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: HeatMapCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: HeatMapCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: HeatMapCustomEvent<any>) => void;
        "padding"?: IBoxModelType;
        "shape"?: string;
        "showTooltip"?: boolean;
        "strokeWidth"?: number;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: string;
        "unitTest"?: boolean;
        "valueAccessor"?: string;
        "width"?: number;
        "wrapLabel"?: boolean;
        "xAccessor"?: string;
        "xAxis"?: IAxisType;
        "xKeyOrder"?: string[];
        "yAccessor"?: string;
        "yAxis"?: IAxisType;
        "yKeyOrder"?: string[];
    }
    interface KeyboardInstructions {
        "chartTag"?: string;
        "disabled"?: boolean;
        "geomType"?: string;
        "groupName"?: string;
        "hasCousinNavigation"?: boolean;
        "isInteractive"?: boolean;
        "language"?: string;
        "uniqueID"?: string;
        "unitTest"?: boolean;
        "width"?: number | string;
    }
    interface LineChart {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colors"?: string[];
        "cursor"?: string;
        "data"?: object[];
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "dotRadius"?: number;
        "height"?: number;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "interactionKeys"?: string[];
        "legend"?: ILegendType;
        "lineCurve"?: string;
        "localization"?: ILocalizationType;
        "mainTitle"?: string;
        "margin"?: IBoxModelType;
        "maxValueOverride"?: number;
        "minValueOverride"?: number;
        "onClickEvent"?: (event: LineChartCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: LineChartCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: LineChartCustomEvent<any>) => void;
        "onHoverEvent"?: (event: LineChartCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: LineChartCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: LineChartCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: LineChartCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: LineChartCustomEvent<any>) => void;
        "ordinalAccessor"?: string;
        "padding"?: IBoxModelType;
        "referenceLines"?: object[];
        "referenceStyle"?: IReferenceStyleType;
        "secondaryLines"?: ISecondaryLinesType;
        "seriesAccessor"?: string;
        "seriesLabel"?: ISeriesLabelType;
        "showBaselineX"?: boolean;
        "showDots"?: boolean;
        "showTooltip"?: boolean;
        "strokeWidth"?: number;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: string;
        "unitTest"?: boolean;
        "valueAccessor"?: string;
        "width"?: number;
        "wrapLabel"?: boolean;
        "xAxis"?: IAxisType;
        "yAxis"?: IAxisType;
    }
    interface ParallelPlot {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colors"?: string[];
        "cursor"?: string;
        "data"?: object[];
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "dotRadius"?: number;
        "height"?: number;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "interactionKeys"?: string[];
        "legend"?: ILegendType;
        "lineCurve"?: string;
        "localization"?: ILocalizationType;
        "mainTitle"?: string;
        "margin"?: IBoxModelType;
        "maxValueOverride"?: number;
        "minValueOverride"?: number;
        "onClickEvent"?: (event: ParallelPlotCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: ParallelPlotCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: ParallelPlotCustomEvent<any>) => void;
        "onHoverEvent"?: (event: ParallelPlotCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: ParallelPlotCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: ParallelPlotCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: ParallelPlotCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: ParallelPlotCustomEvent<any>) => void;
        "ordinalAccessor"?: string;
        "padding"?: IBoxModelType;
        "secondaryLines"?: ISecondaryLinesType;
        "seriesAccessor"?: string;
        "seriesLabel"?: ISeriesLabelType;
        "showBaselineX"?: boolean;
        "showDots"?: boolean;
        "showTooltip"?: boolean;
        "strokeWidth"?: number;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: string;
        "unitTest"?: boolean;
        "valueAccessor"?: string;
        "width"?: number;
        "wrapLabel"?: boolean;
        "xAxis"?: IAxisType;
        "yAxis"?: IAxisType;
    }
    interface PieChart {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "centerSubTitle"?: string;
        "centerTitle"?: string;
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colors"?: string[];
        "cursor"?: string;
        "data"?: object[];
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "height"?: number;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "innerRatio"?: number;
        "interactionKeys"?: string[];
        "labelOffset"?: number;
        "localization"?: ILocalizationType;
        "mainTitle"?: string;
        "margin"?: IBoxModelType;
        "onClickEvent"?: (event: PieChartCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: PieChartCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: PieChartCustomEvent<any>) => void;
        "onHoverEvent"?: (event: PieChartCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: PieChartCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: PieChartCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: PieChartCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: PieChartCustomEvent<any>) => void;
        "ordinalAccessor"?: string;
        "padding"?: IBoxModelType;
        "referenceData"?: object[];
        "referenceStyle"?: IReferenceStyleType;
        "showEdgeLine"?: boolean;
        "showLabelNote"?: boolean;
        "showPercentage"?: boolean;
        "showTooltip"?: boolean;
        "sortOrder"?: string;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: string;
        "unitTest"?: boolean;
        "valueAccessor"?: string;
        "width"?: number;
    }
    interface ScatterPlot {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colors"?: string[];
        "cursor"?: string;
        "data"?: object[];
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "dotOpacity"?: number;
        "dotRadius"?: number;
        "dotSymbols"?: string[];
        "fitLineStyle"?: IReferenceStyleType;
        "groupAccessor"?: string;
        "height"?: number;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "interactionKeys"?: string[];
        "legend"?: ILegendType;
        "localization"?: ILocalizationType;
        "mainTitle"?: string;
        "margin"?: IBoxModelType;
        "onClickEvent"?: (event: ScatterPlotCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: ScatterPlotCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: ScatterPlotCustomEvent<any>) => void;
        "onHoverEvent"?: (event: ScatterPlotCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: ScatterPlotCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: ScatterPlotCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: ScatterPlotCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: ScatterPlotCustomEvent<any>) => void;
        "padding"?: IBoxModelType;
        "referenceLines"?: object[];
        "referenceStyle"?: IReferenceStyleType;
        "showBaselineX"?: boolean;
        "showBaselineY"?: boolean;
        "showFitLine"?: boolean;
        "showTooltip"?: boolean;
        "sizeConfig"?: any;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: string;
        "unitTest"?: boolean;
        "width"?: number;
        "xAccessor"?: string;
        "xAxis"?: IAxisType;
        "xMaxValueOverride"?: number;
        "xMinValueOverride"?: number;
        "yAccessor"?: string;
        "yAxis"?: IAxisType;
        "yMaxValueOverride"?: number;
        "yMinValueOverride"?: number;
    }
    interface StackedBarChart {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "barIntervalRatio"?: number;
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colors"?: string[];
        "cursor"?: string;
        "data"?: object[];
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "groupAccessor"?: string;
        "height"?: number;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "interactionKeys"?: string[];
        "layout"?: string;
        "legend"?: ILegendType;
        "localization"?: ILocalizationType;
        "mainTitle"?: string;
        "margin"?: IBoxModelType;
        "maxValueOverride"?: number;
        "minValueOverride"?: number;
        "normalized"?: boolean;
        "onClickEvent"?: (event: StackedBarChartCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: StackedBarChartCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: StackedBarChartCustomEvent<any>) => void;
        "onHoverEvent"?: (event: StackedBarChartCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: StackedBarChartCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: StackedBarChartCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: StackedBarChartCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: StackedBarChartCustomEvent<any>) => void;
        "ordinalAccessor"?: string;
        "padding"?: IBoxModelType;
        "referenceLines"?: object[];
        "referenceStyle"?: IReferenceStyleType;
        "roundedCorner"?: number;
        "showTooltip"?: boolean;
        "showTotalValue"?: boolean;
        "showZeroLabels"?: boolean;
        "sortOrder"?: string;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: string;
        "unitTest"?: boolean;
        "valueAccessor"?: string;
        "width"?: number;
        "wrapLabel"?: boolean;
        "xAxis"?: IAxisType;
        "yAxis"?: IAxisType;
    }
    interface WorldMap {
        "accessibility"?: IAccessibilityType;
        "animationConfig"?: IAnimationConfig;
        "annotations"?: object[];
        "clickHighlight"?: object[];
        "clickStyle"?: IClickStyleType;
        "colorPalette"?: string;
        "colorSteps"?: number;
        "colors"?: string[];
        "countryStyle"?: ICountryStyleType;
        "cursor"?: string;
        "data"?: object[];
        "dataKeyNames"?: object;
        "dataLabel"?: IDataLabelType;
        "groupAccessor"?: string;
        "height"?: number;
        "highestHeadingLevel"?: string | number;
        "hoverHighlight"?: object;
        "hoverOpacity"?: number;
        "hoverStyle"?: IHoverStyleType;
        "interactionKeys"?: string[];
        "joinAccessor"?: string;
        "joinNameAccessor"?: string;
        "latitudeAccessor"?: string;
        "legend"?: ILegendType;
        "localization"?: ILocalizationType;
        "longitudeAccessor"?: string;
        "mainTitle"?: string;
        "mapProjection"?: string;
        "mapScaleZoom"?: number;
        "margin"?: IBoxModelType;
        "markerAccessor"?: string;
        "markerNameAccessor"?: string;
        "markerStyle"?: IMapMarkerStyleType;
        "maxValueOverride"?: number;
        "minValueOverride"?: number;
        "onClickEvent"?: (event: WorldMapCustomEvent<any>) => void;
        "onDrawEndEvent"?: (event: WorldMapCustomEvent<any>) => void;
        "onDrawStartEvent"?: (event: WorldMapCustomEvent<any>) => void;
        "onHoverEvent"?: (event: WorldMapCustomEvent<any>) => void;
        "onInitialLoadEndEvent"?: (event: WorldMapCustomEvent<any>) => void;
        "onInitialLoadEvent"?: (event: WorldMapCustomEvent<any>) => void;
        "onMouseOutEvent"?: (event: WorldMapCustomEvent<any>) => void;
        "onTransitionEndEvent"?: (event: WorldMapCustomEvent<any>) => void;
        "padding"?: IBoxModelType;
        "quality"?: string;
        "showGridlines"?: boolean;
        "showTooltip"?: boolean;
        "sortOrder"?: string;
        "subTitle"?: string | ISubTitleType;
        "suppressEvents"?: boolean;
        "tooltipLabel"?: ITooltipLabelType;
        "uniqueID"?: string;
        "unitTest"?: boolean;
        "valueAccessor"?: string;
        "width"?: number;
    }
    interface IntrinsicElements {
        "alluvial-diagram": AlluvialDiagram;
        "bar-chart": BarChart;
        "circle-packing": CirclePacking;
        "clustered-bar-chart": ClusteredBarChart;
        "data-table": DataTable;
        "dumbbell-plot": DumbbellPlot;
        "heat-map": HeatMap;
        "keyboard-instructions": KeyboardInstructions;
        "line-chart": LineChart;
        "parallel-plot": ParallelPlot;
        "pie-chart": PieChart;
        "scatter-plot": ScatterPlot;
        "stacked-bar-chart": StackedBarChart;
        "world-map": WorldMap;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "alluvial-diagram": LocalJSX.AlluvialDiagram & JSXBase.HTMLAttributes<HTMLAlluvialDiagramElement>;
            "bar-chart": LocalJSX.BarChart & JSXBase.HTMLAttributes<HTMLBarChartElement>;
            "circle-packing": LocalJSX.CirclePacking & JSXBase.HTMLAttributes<HTMLCirclePackingElement>;
            "clustered-bar-chart": LocalJSX.ClusteredBarChart & JSXBase.HTMLAttributes<HTMLClusteredBarChartElement>;
            "data-table": LocalJSX.DataTable & JSXBase.HTMLAttributes<HTMLDataTableElement>;
            "dumbbell-plot": LocalJSX.DumbbellPlot & JSXBase.HTMLAttributes<HTMLDumbbellPlotElement>;
            "heat-map": LocalJSX.HeatMap & JSXBase.HTMLAttributes<HTMLHeatMapElement>;
            "keyboard-instructions": LocalJSX.KeyboardInstructions & JSXBase.HTMLAttributes<HTMLKeyboardInstructionsElement>;
            "line-chart": LocalJSX.LineChart & JSXBase.HTMLAttributes<HTMLLineChartElement>;
            "parallel-plot": LocalJSX.ParallelPlot & JSXBase.HTMLAttributes<HTMLParallelPlotElement>;
            "pie-chart": LocalJSX.PieChart & JSXBase.HTMLAttributes<HTMLPieChartElement>;
            "scatter-plot": LocalJSX.ScatterPlot & JSXBase.HTMLAttributes<HTMLScatterPlotElement>;
            "stacked-bar-chart": LocalJSX.StackedBarChart & JSXBase.HTMLAttributes<HTMLStackedBarChartElement>;
            "world-map": LocalJSX.WorldMap & JSXBase.HTMLAttributes<HTMLWorldMapElement>;
        }
    }
}
